name: Combined Component Build

on:
  workflow_dispatch:
    inputs:
      build_target:
        type: choice
        description: 'Which component to build?'
        required: true
        default: 'all'
        options:
          - 'all'
          - 'box64'
          - 'fexcore'
          - 'turnip'

permissions:
  contents: write

defaults:
  run:
    shell: 'bash --noprofile --norc -Eeuo pipefail {0}'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-box64:
    name: Build Box64
    if: github.event.inputs.build_target == 'all' || github.event.inputs.build_target == 'box64'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      RELEASE_INFO: ${{ steps.set_output.outputs.RELEASE_INFO }}
    env:
      GH_TOKEN: ${{ github.token }}
      REPO_FULL: ${{ github.repository }}
      OWNER: ptitSeb
      REPO: box64
      NDK_VERSION: r26b
      API_LEVEL: 30
      BUILD_TYPE: Release

    steps:
      - name: Install dependencies
        run: |
          sudo apt-get -yqq update
          sudo apt-get -yqq install --no-install-recommends \
            git cmake make ninja-build python3 zstd file jq curl unzip ca-certificates \
            binutils gh

      - name: Resolve upstream default branch HEAD
        id: upstream
        run: |
          set -Eeuo pipefail
          API="https://api.github.com"
          auth=(-H "Authorization: Bearer ${GH_TOKEN}")
          ua=(-H "User-Agent: ${GITHUB_REPOSITORY:-box64-bionic-nightly}")
          ver=(-H "X-GitHub-Api-Version: 2022-11-28" -H "Accept: application/vnd.github+json")
          fetch() { curl -fsSL --retry 6 --retry-delay 2 --retry-all-errors "${auth[@]}" "${ua[@]}" "${ver[@]}" "$1"; }

          default_branch="$(fetch "$API/repos/${OWNER}/${REPO}" | jq -r .default_branch)"
          [[ -z "$default_branch" || "$default_branch" == "null" ]] && default_branch="main"

          sha="$(fetch "$API/repos/${OWNER}/${REPO}/commits/${default_branch}" | jq -r .sha)"
          [[ -z "$sha" || "$sha" == "null" ]] && { echo "::error::Failed to resolve upstream HEAD SHA"; exit 1; }

          short="${sha:0:7}"
          echo "sha=${sha}"   >> "$GITHUB_OUTPUT"
          echo "short=${short}" >> "$GITHUB_OUTPUT"

      - name: Resolve latest stable tag and derive develop
        id: ver
        run: |
          set -Eeuo pipefail
          API="https://api.github.com"
          auth=(-H "Authorization: Bearer ${GH_TOKEN}")
          ua=(-H "User-Agent: ${GITHUB_REPOSITORY:-box64-bionic-nightly}")
          ver=(-H "X-GitHub-Api-Version: 2022-11-28" -H "Accept: application/vnd.github+json")
          fetch() { curl -fsSL --retry 6 --retry-delay 2 --retry-all-errors "${auth[@]}" "${ua[@]}" "${ver[@]}" "$1"; }

          releases="$(fetch "$API/repos/${OWNER}/${REPO}/releases?per_page=100")"
          stable_tag="$(
            jq -r '
              [ .[] | select(.draft==false)
                | .tag_name
                | select(test("^v[0-9]+\\.[0-9]+\\.[0-9]+$"))
                | capture("^v(?<maj>[0-9]+)\\.(?<min>[0-9]+)\\.(?<pat>[0-9]+)$")
                | .maj|=tonumber | .min|=tonumber | .pat|=tonumber
              ]
              | sort_by(.maj, .min, .pat)
              | last
              | if . then "v\(.maj).\(.min).\(.pat)" else "" end
            ' <<<"$releases"
          )"
          [[ -n "$stable_tag" ]] || { echo "::error::Failed to resolve latest stable tag"; exit 1; }

          stable="${stable_tag#v}"
          IFS=. read -r MAJ MIN PAT <<<"$stable"
          DEV_PATCH=$((PAT + 1))
          DEV="${MAJ}.${MIN}.${DEV_PATCH}"
          echo "develop=${DEV}" >> "$GITHUB_OUTPUT"

      - name: Decide date code (UTC)
        id: date
        run: echo "datecode=$(date -u +%y%m%d)" >> "$GITHUB_OUTPUT"

      - name: Checkout upstream Box64 (exact commit)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.OWNER }}/${{ env.REPO }}
          ref: ${{ steps.upstream.outputs.sha }}
          submodules: recursive
          path: src
          fetch-depth: 1

      - name: Prepare Android NDK ${{ env.NDK_VERSION }} (idempotent)
        run: |
          set -Eeuo pipefail
          NDK_BASE="android-ndk-${NDK_VERSION}"
          URL="https://dl.google.com/android/repository/${NDK_BASE}-linux.zip"
          NDK_DIR="${RUNNER_TEMP:-$PWD}/${NDK_BASE}"

          if [[ -d "$NDK_DIR" && ! -x "$NDK_DIR/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android${API_LEVEL}-clang" ]]; then
            echo "::warning::Stale or partial NDK at $NDK_DIR; removing"
            rm -rf "$NDK_DIR"
          fi

          if [[ ! -d "$NDK_DIR" ]]; then
            curl -fsSL -o ndk.zip "$URL"
            unzip -q -o ndk.zip -d "${RUNNER_TEMP:-$PWD}"
          else
            echo "Reusing existing NDK at $NDK_DIR"
          fi

          echo "NDK=$NDK_DIR" >> $GITHUB_ENV
          echo "BOX64_COMPILER=$NDK_DIR/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android${API_LEVEL}-clang" >> $GITHUB_ENV
          echo "BOX64_PLATFORM_MACRO=-DANDROID=1 -DARM_DYNAREC=1 -DBAD_SIGNAL=1" >> $GITHUB_ENV

      - name: Configure
        run: |
          set -Eeuo pipefail
          cd src
          rm -rf build && mkdir -p build && cd build
          cmake .. \
            -DCMAKE_C_COMPILER="${BOX64_COMPILER}" \
            -DANDROID=1 -DARM_DYNAREC=1 -DBAD_SIGNAL=1 \
            -DTERMUX=0 \
            -DCMAKE_BUILD_TYPE=${BUILD_TYPE} \
            -DHAVE_TRACE=0 \
            -DZYDIS3=0 \
            -DSTATICBUILD=0 \
            -DBOX32=0 \
            -DCI=0 \
            -DCMAKE_VERBOSE_MAKEFILE:BOOL=ON

      - name: Build (parallel)
        run: cmake --build src/build -j"$(nproc)"

      - name: Strip binary (safe)
        run: |
          set -Eeuo pipefail
          BIN="src/build/box64"
          [[ -f "$BIN" ]] || { echo "::error::Missing binary: $BIN"; exit 1; }
          STRIP_BIN="${NDK}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-strip"
          if [[ -x "$STRIP_BIN" ]]; then
            "$STRIP_BIN" --strip-unneeded "$BIN"
          else
            strip --strip-unneeded "$BIN"
          fi
          file "$BIN"

      - name: Package ZIP
        id: package
        run: |
          set -Eeuo pipefail
          mkdir -p artifacts
          cp src/build/box64 artifacts/box64
          (cd artifacts && zip box64-latest.zip box64)
          echo "FILENAME=box64-latest.zip" >> "$GITHUB_OUTPUT"

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: box64-artifact
          path: artifacts/box64-latest.zip
          retention-days: 1

      - name: Set Output Info
        id: set_output
        env:
          SHA: ${{ steps.upstream.outputs.sha }}
          SHORT: ${{ steps.upstream.outputs.short }}
          DATECODE: ${{ steps.date.outputs.datecode }}
          DEV: ${{ steps.ver.outputs.develop }}
        run: |
          echo "RELEASE_INFO=**Box64**: ${DEV}-${DATECODE} ([${SHORT}](https://github.com/ptitSeb/box64/commit/${SHA}))" >> "$GITHUB_OUTPUT"

  build-fexcore:
    name: Build FEXCore
    if: github.event.inputs.build_target == 'all' || github.event.inputs.build_target == 'fexcore'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      RELEASE_INFO: ${{ steps.set_output.outputs.RELEASE_INFO }}
    env:
      FEX_REPO: ${{ vars.FEX_REPO || 'FEX-Emu/FEX' }}
      TOOLCHAIN_DIR: /opt/llvm-mingw
      GH_TOKEN: ${{ github.token }}
      LLVM_MINGW_TAG: ${{ vars.LLVM_MINGW_TAG || '20250920' }}
      DO_EC_HOTFIX: ${{ (github.event_name != 'workflow_dispatch') || 'true' }}

    steps:
      - name: Collect date (UTC) and latest main commit
        id: collect
        run: |
          set -Eeuo pipefail
          DATE=$(date -u +%y%m%d)
          echo "date=$DATE" >> "$GITHUB_OUTPUT"

          API="https://api.github.com"
          auth=(-H "Authorization: Bearer ${GH_TOKEN}")
          ver=(-H "Accept: application/vnd.github+json")

          json=$(curl -fsSL "${auth[@]}" "${ver[@]}" "$API/repos/${FEX_REPO}/commits/main")
          SHA=$(jq -r '.sha' <<<"$json")
          SHORT=${SHA:0:7}

          rel=$(curl -fsSL "${auth[@]}" "${ver[@]}" "$API/repos/${FEX_REPO}/releases?per_page=100" || true)
          tags=$(curl -fsSL "${auth[@]}" "${ver[@]}" "$API/repos/${FEX_REPO}/tags?per_page=100" || true)

          candidates=$(
            { jq -r '.[].tag_name // empty' <<<"$rel"; jq -r '.[].name // empty' <<<"$tags"; } \
            | grep -E '^FEX-[0-9]{4}(\.[1-9])?$' | sort -u
          )

          if [[ -z "${candidates}" ]]; then
            echo "::error::No FEX-YYMM(.P) style tags/releases found in ${FEX_REPO}"; exit 1
          fi

          best=$(printf '%s\n' "$candidates" | awk -F'-' '
                      {
                        n=$2
                        split(n, a, ".")
                        base=a[1]
                        p=a[2]
                        pv = (p == "" ? 0 : p)
                        if (base ~ /^[0-9]{4}$/ && (p == "" || p ~ /^[1-9]$/)) {
                          key = base*10 + pv
                          if (key>max) { max=key; b=base; patch=p }
                        }
                      }
                      END {
                        if (max=="") exit 1;
                        if (patch=="") printf("%s", b); else printf("%s.%s", b, patch);
                      }
                    ')
          
          STABLE="$best"
          echo "sha=$SHA" >> "$GITHUB_OUTPUT"
          echo "shortsha=$SHORT" >> "$GITHUB_OUTPUT"
          echo "stable=$STABLE" >> "$GITHUB_OUTPUT"

      - name: Install host tooling
        run: |
          sudo apt-get -yqq update
          sudo apt-get -yqq install --no-install-recommends \
            curl xz-utils jq ca-certificates \
            git ninja-build cmake pkg-config \
            build-essential python3 zstd gh perl dos2unix zip

      - name: Download pinned llvm-mingw
        env:
          TAG: ${{ env.LLVM_MINGW_TAG }}
        run: |
          set -Eeuo pipefail
          gh release download "$TAG" -R bylaws/llvm-mingw \
            -p '*ucrt-ubuntu-22.04-x86_64.tar.xz' -O /tmp/llvm-mingw.tar.xz --clobber
          sudo mkdir -p /opt/llvm-mingw
          sudo tar -C /opt/llvm-mingw --strip-components=1 -xJf /tmp/llvm-mingw.tar.xz
          echo "/opt/llvm-mingw/bin" >> "$GITHUB_PATH"

      - name: Clone FEX at decided commit
        env:
          SHA: ${{ steps.collect.outputs.sha }}
        run: |
          set -Eeuo pipefail
          git init src
          git -C src remote add origin https://github.com/${FEX_REPO}.git
          git -C src -c protocol.version=2 fetch --depth=1 --filter=blob:none origin "$SHA"
          git -C src checkout --detach FETCH_HEAD
          git -C src submodule update --init --recursive --depth=1 --recommend-shallow

      - name: Configure git identity
        run: |
          git -C src config user.name "FEXCore Nightly Builder"
          git -C src config user.email "builder@users.noreply.github.com"

      - name: ARM64EC Module.S x23â†’x12 hotfix (strict, no-heredoc)
        if: ${{ env.DO_EC_HOTFIX == 'true' }}
        run: |
          set -Eeuo pipefail
          FILE="${GITHUB_WORKSPACE}/src/Source/Windows/ARM64EC/Module.S"
          [[ -f "$FILE" ]] || { echo "::error::File not found: $FILE"; exit 1; }

          L1='  ldursw x23, [x17, #-0x4] // Load either the entry thunk offset or the calling instruction.'
          L2='  cmp w23, w16'
          L3='  and x23, x23, #-0x4'
          L4='  add x17, x17, x23 // Resolve entry thunk address.'
          for n in "$L1" "$L2" "$L3" "$L4"; do
            grep -Fqx -- "$n" "$FILE" || { echo "::error::Upstream drift in $FILE (expected line missing): [$n]"; exit 1; }
          done
 
          perl -0777 -i -pe 's{^\Q  ldursw x23, [x17, #-0x4] // Load either the entry thunk offset or the calling instruction.\E$}{  ldursw x12, [x17, #-0x4] // Load either the entry thunk offset or the calling instruction.\n// [CI hotfix: x23->x12]}m; s{^\Q  cmp w23, w16\E$}{  cmp w12, w16}m; s{^\Q  and x23, x23, #-0x4\E$}{  and x12, x12, #-0x4}m; s{^\Q  add x17, x17, x23 // Resolve entry thunk address.\E$}{  add x17, x17, x12 // Resolve entry thunk address.}m;' "$FILE"
      
          NEW1='  ldursw x12, [x17, #-0x4] // Load either the entry thunk offset or the calling instruction.\n// [CI hotfix: x23->x12]'
          NEW2='  cmp w12, w16'
          NEW3='  and x12, x12, #-0x4'
          NEW4='  add x17, x17, x12 // Resolve entry thunk address.'
          for n in "$NEW1" "$NEW2" "$NEW3" "$NEW4"; do
            grep -Fqx -- "$n" "$FILE" || true
          done
          for n in "$L1" "$L2" "$L3" "$L4"; do
            ! grep -Fqx -- "$n" "$FILE" || { echo "::error::Old line still present after patch: [$n]"; exit 1; }
          done
      
          echo "::notice::Applied strict Module.S hotfix at $FILE"

      - name: Build (ARM64EC + AArch64)
        env:
          DATE: ${{ steps.collect.outputs.date }}
        run: |
          set -Eeuo pipefail
          cd "${GITHUB_WORKSPACE}/src"

          STAGE_ARM64EC="${GITHUB_WORKSPACE}/stage-arm64ec-${DATE}"
          STAGE_AARCH64="${GITHUB_WORKSPACE}/stage-aarch64-${DATE}"
          rm -rf "$STAGE_ARM64EC" "$STAGE_AARCH64"
          mkdir -p "$STAGE_ARM64EC" "$STAGE_AARCH64"

          rm -rf build-arm64ec && mkdir build-arm64ec && cd build-arm64ec
          cmake -GNinja \
            --log-level=WARNING \
            -Wno-dev \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_TOOLCHAIN_FILE=../Data/CMake/toolchain_mingw.cmake \
            -DCMAKE_INSTALL_LIBDIR=/usr/lib/wine/aarch64-windows \
            -DENABLE_LTO=False \
            -DMINGW_BUILD=1 \
            -DCMAKE_DISABLE_FIND_PACKAGE_fmt=true \
            -DCMAKE_DISABLE_FIND_PACKAGE_range-v3=true \
            -DCMAKE_C_COMPILER_WORKS=1 \
            -DCMAKE_CXX_COMPILER_WORKS=1 \
            -DMINGW_TRIPLE=arm64ec-w64-mingw32 \
            -DBUILD_TESTING=False \
            -DENABLE_FEX_ALLOCATOR=True \
            -DCMAKE_INSTALL_PREFIX=/usr ..
          NINJA_STATUS="" ninja
          DESTDIR="$STAGE_ARM64EC" ninja install
          cd ..

          git -C "${GITHUB_WORKSPACE}/src" restore --source=HEAD -- "Source/Windows/ARM64EC/Module.S" \
            || git -C "${GITHUB_WORKSPACE}/src" checkout -- "Source/Windows/ARM64EC/Module.S"
          echo "::notice::Reverted Module.S to HEAD for AArch64 build"

          rm -rf build-wow64 && mkdir build-wow64 && cd build-wow64
          cmake -GNinja \
            --log-level=WARNING \
            -Wno-dev \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_TOOLCHAIN_FILE=../Data/CMake/toolchain_mingw.cmake \
            -DCMAKE_INSTALL_LIBDIR=/usr/lib/wine/aarch64-windows \
            -DENABLE_LTO=False \
            -DMINGW_BUILD=1 \
            -DCMAKE_DISABLE_FIND_PACKAGE_fmt=true \
            -DCMAKE_DISABLE_FIND_PACKAGE_range-v3=true \
            -DCMAKE_C_COMPILER_WORKS=1 \
            -DCMAKE_CXX_COMPILER_WORKS=1 \
            -DMINGW_TRIPLE=aarch64-w64-mingw32 \
            -DBUILD_TESTING=False \
            -DENABLE_FEX_ALLOCATOR=True \
            -DCMAKE_INSTALL_PREFIX=/usr ..
          NINJA_STATUS="" ninja
          DESTDIR="$STAGE_AARCH64" ninja install
          cd ..

      - name: Package ZIP
        id: package
        env:
          DATE: ${{ steps.collect.outputs.date }}
        run: |
          set -Eeuo pipefail
          PACKAGE_DIR="${GITHUB_WORKSPACE}/FEXCore_Pkg"
          rm -rf "$PACKAGE_DIR" && mkdir -p "$PACKAGE_DIR"
          
          STAGE_ARM64EC="${GITHUB_WORKSPACE}/stage-arm64ec-${DATE}"
          STAGE_AARCH64="${GITHUB_WORKSPACE}/stage-aarch64-${DATE}"

          for ST in "$STAGE_ARM64EC" "$STAGE_AARCH64"; do
            SRC="$ST/usr/lib/wine/aarch64-windows"
            if [[ -d "$SRC" ]]; then
              find "$SRC" -type f -name '*.dll' -exec cp {} "$PACKAGE_DIR/" \;
            else
              echo "::warning::Expected install dir not found: $SRC"
            fi
          done

          if command -v llvm-strip >/dev/null 2>&1; then
            find "$PACKAGE_DIR" -maxdepth 1 -type f -name '*.dll' -print0 | xargs -0 -I{} llvm-strip -s "{}" || true
          fi

          (cd "$PACKAGE_DIR" && find . -maxdepth 1 -type f -name '*.dll' -print) | grep -q . || { echo "::error::No DLLs discovered in $PACKAGE_DIR"; exit 1; }
          
          mkdir -p artifacts
          (cd "$PACKAGE_DIR" && zip ../artifacts/fexcore-latest.zip *.dll)
          echo "FILENAME=fexcore-latest.zip" >> "$GITHUB_OUTPUT"

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: fexcore-artifact
          path: artifacts/fexcore-latest.zip
          retention-days: 1

      - name: Set Output Info
        id: set_output
        env:
          SHA: ${{ steps.collect.outputs.sha }}
          SHORTSHA: ${{ steps.collect.outputs.shortsha }}
          STABLE: ${{ steps.collect.outputs.stable }}
          DATE: ${{ steps.collect.outputs.date }}
        run: |
          echo "RELEASE_INFO=**FEXCore**: ${STABLE}-${DATE} ([${SHORTSHA}](https://github.com/FEX-Emu/FEX/commit/${SHA}))" >> "$GITHUB_OUTPUT"

  build-turnip:
    name: Build Turnip
    if: github.event.inputs.build_target == 'all' || github.event.inputs.build_target == 'turnip'
    runs-on: ubuntu-24.04
    outputs:
      RELEASE_INFO: ${{ steps.set_output.outputs.RELEASE_INFO }}
    env:
      WORKDIR: ${{ github.workspace }}/turnip_workdir
      NDKVER: "android-ndk-r29"
      SDKVER: "35"
      MESAREPO: "https://gitlab.freedesktop.org/mesa/mesa.git"

    steps:
    - uses: actions/checkout@v3

    - name: Prepare environment and install dependencies
      run: |
        sudo sed -i 's/^Types: deb$/Types: deb deb-src/' /etc/apt/sources.list.d/ubuntu.sources
        sudo apt update
        sudo apt build-dep mesa -y
        sudo apt install -y patchelf unzip curl python3-pip zip glslang-tools git
        pip install mako

    - name: Prepare workdir, download NDK and Mesa
      run: |
        echo "Preparing work directory in $WORKDIR"
        mkdir -p "$WORKDIR"
        cd "$WORKDIR"
        
        echo "Downloading Android NDK ($NDKVER)..."
        curl -L -o "$NDKVER-linux.zip" "https://dl.google.com/android/repository/${NDKVER}-linux.zip"
        echo "Extracting Android NDK..."
        unzip -q "$NDKVER-linux.zip"
        
        echo "Cloning Mesa source..."
        git clone --depth=1 "$MESAREPO" mesa-main

    - name: Build Turnip driver (libvulkan_freedreno)
      working-directory: ${{ github.workspace }}/turnip_workdir/mesa-main
      run: |
        NDK_PATH="$WORKDIR/$NDKVER/toolchains/llvm/prebuilt/linux-x86_64/bin"
        BIN_DIR="$WORKDIR/bin"
        
        mkdir -p "$BIN_DIR"
        ln -sf "$NDK_PATH/clang" "$BIN_DIR/cc"
        ln -sf "$NDK_PATH/clang++" "$BIN_DIR/c++"
        export PATH="$BIN_DIR:$NDK_PATH:$PATH"
        export CC=clang
        export CXX=clang++
        export AR=llvm-ar
        export RANLIB=llvm-ranlib
        export STRIP=llvm-strip
        export OBJDUMP=llvm-objdump
        export OBJCOPY=llvm-objcopy
        export LDFLAGS="-fuse-ld=lld"
        
        echo "Generating build files..."
        
        cat <<EOF >"android-aarch64.txt"
        [binaries]
        ar = '$NDK_PATH/llvm-ar'
        c = ['ccache', '$NDK_PATH/aarch64-linux-android$SDKVER-clang']
        cpp = ['ccache', '$NDK_PATH/aarch64-linux-android$SDKVER-clang++', '-fno-exceptions', '-fno-unwind-tables', '-fno-asynchronous-unwind-tables', '--start-no-unused-arguments', '-static-libstdc++', '--end-no-unused-arguments']
        c_ld = '$NDK_PATH/ld.lld'
        cpp_ld = '$NDK_PATH/ld.lld'
        strip = '$NDK_PATH/aarch64-linux-android-strip'
        pkg-config = ['env', 'PKG_CONFIG_LIBDIR=$NDK_PATH/pkg-config', '/usr/bin/pkg-config']

        [host_machine]
        system = 'android'
        cpu_family = 'aarch64'
        cpu = 'armv8'
        endian = 'little'
        EOF

        cat <<EOF >"native.txt"
        [build_machine]
        c = ['ccache', 'clang']
        cpp = ['ccache', 'clang++']
        ar = 'llvm-ar'
        strip = 'llvm-strip'
        c_ld = 'ld.lld'
        cpp_ld = 'ld.lld'
        system = 'linux'
        cpu_family = 'x86_64'
        cpu = 'x86_64'
        endian = 'little'
        EOF
        
        meson setup build-android-aarch64 \
          --cross-file "android-aarch64.txt" \
          --native-file "native.txt" \
          -Dbuildtype=release \
          -Dplatforms=android \
          -Dplatform-sdk-version="$SDKVER" \
          -Dandroid-stub=true \
          -Dgallium-drivers= \
          -Dvulkan-drivers=freedreno \
          -Dvulkan-beta=true \
          -Dfreedreno-kmds=kgsl \
          -Db_lto=true \
          -Db_lto_mode=thin \
          -Dstrip=true \
          -Degl=disabled &> "$WORKDIR/meson_log"
        
        echo "Compiling build files..."
        ninja -C build-android-aarch64 &> "$WORKDIR/ninja_log"
        
        echo "Checking for built library..."
        if ! [ -a "build-android-aarch64/src/freedreno/vulkan/libvulkan_freedreno.so" ]; then
          echo "Build failed! Library not found." && exit 1
        fi
        echo "Build successful."

    - name: Package Turnip driver (no metadata)
      run: |
        libname="libvulkan_freedreno.so"
        BUILT_LIB_PATH="$WORKDIR/mesa-main/build-android-aarch64/src/freedreno/vulkan/$libname"
        
        echo "Copying library and using patchelf..."
        cp "$BUILT_LIB_PATH" "$WORKDIR/$libname"
        cd "$WORKDIR"
        patchelf --set-soname $libname $libname
        
        echo "Creating zip archive..."
        zip -9 "$WORKDIR/turnip-latest.zip" $libname
        
        if ! [ -a "$WORKDIR/turnip-latest.zip" ]; then
          echo "Packing turnip-latest.zip failed!" && exit 1
        fi

    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: turnip-artifact
        path: ${{ env.WORKDIR }}/turnip-latest.zip
        retention-days: 1

    - name: Set Output Info
      id: set_output
      run: |
        cd "$WORKDIR/mesa-main"
        SHA=$(git rev-parse HEAD)
        SHORT=$(git rev-parse --short HEAD)
        DATE=$(date -u +%y%m%d)
        echo "RELEASE_INFO=**Turnip (Mesa)**: ${DATE} ([${SHORT}](https://gitlab.freedesktop.org/mesa/mesa/-/commit/${SHA}))" >> "$GITHUB_OUTPUT"

  create-release:
    name: Create Combined Release
    runs-on: ubuntu-latest
    if: always()
    needs: [build-box64, build-fexcore, build-turnip]
    
    steps:
      - name: Install GitHub CLI
        run: sudo apt-get install -yq gh

      - name: Download Box64 artifact
        if: needs.build-box64.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: box64-artifact
          path: artifacts

      - name: Download FEXCore artifact
        if: needs.build-fexcore.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: fexcore-artifact
          path: artifacts

      - name: Download Turnip artifact
        if: needs.build-turnip.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: turnip-artifact
          path: artifacts

      - name: Update Release Notes
        id: generate_notes
        env:
          GH_TOKEN: ${{ github.token }}
          BOX64_INFO: ${{ needs.build-box64.outputs.RELEASE_INFO }}
          FEXCORE_INFO: ${{ needs.build-fexcore.outputs.RELEASE_INFO }}
          TURNIP_INFO: ${{ needs.build-turnip.outputs.RELEASE_INFO }}
        run: |
          set -e
          NOTES_FILE="current_notes.md"
          
          gh release view combined-latest -R ${{ github.repository }} --json body --jq .body > $NOTES_FILE || echo -e "Automated Combined Release\n" > $NOTES_FILE

          if [ "${{ needs.build-box64.result }}" == "success" ]; then
            if grep -q "^\*\*Box64\*\*:" $NOTES_FILE; then
              sed -i "s|^\*\*Box64\*\*.*|$BOX64_INFO|" $NOTES_FILE
            else
              echo "$BOX64_INFO" >> $NOTES_FILE
            fi
          fi

          if [ "${{ needs.build-fexcore.result }}" == "success" ]; then
            if grep -q "^\*\*FEXCore\*\*:" $NOTES_FILE; then
              sed -i "s|^\*\*FEXCore\*\*.*|$FEXCORE_INFO|" $NOTES_FILE
            else
              echo "$FEXCORE_INFO" >> $NOTES_FILE
            fi
          fi

          if [ "${{ needs.build-turnip.result }}" == "success" ]; then
            if grep -q "^\*\*Turnip (Mesa)\*\*:" $NOTES_FILE; then
              sed -i "s|^\*\*Turnip (Mesa)\*\*.*|$TURNIP_INFO|" $NOTES_FILE
            else
              echo "$TURNIP_INFO" >> $NOTES_FILE
            fi
          fi
          
          echo "NOTES_PATH=$NOTES_FILE" >> "$GITHUB_OUTPUT"

      - name: Create or Edit GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh release edit combined-latest -R ${{ github.repository }} -F ${{ steps.generate_notes.outputs.NOTES_PATH }} \
          || gh release create combined-latest -R ${{ github.repository }} \
             -t "Combined (Latest)" \
             -F ${{ steps.generate_notes.outputs.NOTES_PATH }}

      - name: Upload Release Assets
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ -d "artifacts" ] && [ "$(ls -A artifacts)" ]; then
            gh release upload combined-latest artifacts/*.zip -R ${{ github.repository }} --clobber
          else
            echo "No new artifacts to upload."
          fi